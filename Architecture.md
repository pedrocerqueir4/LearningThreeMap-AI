# High-Level Architecture
## Logical Components

### Frontend (SPA)

Pages:
- Conversation list / home
- Conversation view (chat + graph)

UI “zones” (in conversation view):
- Left: list of conversations
- Center: chat interface (messages list, input) and visualization of nodes (React Flow, representing the same conversation)

### Backend (Worker + Hono)

Routes grouped by responsibility:
- /api/conversations – create, list, get details
- /api/messages – create new message (and trigger AI call)
- /api/graph – get graph for a conversation (nodes + edges)
- /api/graph/:conversationId/positions – persist node positions when the user drags nodes
- /api/graph/:conversationId/nodes/:nodeId – delete a node subtree, respecting join edges

Integrations:
- D1 binding for persistence
- AI HTTP API

### Database (D1)

Basic relational schema:
- conversations
- messages
- nodes
- edges

# Data Model
## Tables

1. conversations

- id (string/UUID)
- title (string)
- created_at (timestamp)
- updated_at (timestamp)

2. messages

- id
- conversation_id
- author (enum/string: 'user' | 'ai')
- content (text)
- created_at (timestamp)

3. nodes

- id
- conversation_id
- message_id (nullable for non-message nodes, current implementation links user/ai nodes to messages)
- type (string: 'user' | 'ai')
- label (short text for display, usually content or truncated content)
- created_at
- pos_x (nullable – last saved X position in the React Flow canvas)
- pos_y (nullable – last saved Y position in the React Flow canvas)

4. edges

- id
- conversation_id
- source_node_id 
- target_node_id (can have multiple)
- created_at


## API Design 

Base URL
Backend Worker: /api/...

### 1. Conversations

1. Create conversation
- POST /api/conversations
- Body: { "title": string } (auto-generated by backend if empty)
- Response: { "id": string, "title": string, "created_at": string }

2. List conversations
- GET /api/conversations
- Response: [{ "id": string, "title": string, "created_at": string }]

3. Update conversation title
- PUT /api/conversations/:conversationId
- Body: { "title": string }
- Response 200: updated conversation

4. Delete conversation
- DELETE /api/conversations/:conversationId
- Response 204 on success

### 2. Messages & AI

1. Send user message & get AI reply
- POST /api/messages
- Body:
  {
    "conversationId": "string",
    "content": "user message text",
    "fromNodeIds": ["optional", "node", "ids"]
  }

2. Backend steps:
- Insert user message into messages.
- Create user node and (optionally) edges from selected parent nodes (`fromNodeIds`).
- Build context (recent messages from the ancestor nodes subgraph) for AI call if `fromNodeIds` are provided.
- Call Google Gemini (Generative Language API) using API key from environment variable `AI_API_KEY`.
- Insert AI message into messages.
- Create AI node and an edge user_node → ai_node.
- Return:
  {
    "userMessage": { ... },
    "aiMessage": { ... },
    "graphDelta": {
      "newNodes": [...],
      "newEdges": [...]
    }
  }
- Optionally, after the first AI answer of a new conversation, call Gemini again to auto-generate a short conversation title and persist it.

### 3. Graph

1. Get full graph for a conversation
- GET /api/graph/:conversationId
- Response:
  {
    "nodes": [...],
    "edges": [...]
  }

Nodes include ids, labels, type, author, etc.
Edges include ids, source, target.

2. Update node positions
- POST /api/graph/:conversationId/positions
- Body: { positions: [{ nodeId, x, y }, ...] }
- Persists `pos_x` and `pos_y` in D1 for each node to keep the user-defined layout.

3. Delete node subtree
- DELETE /api/graph/:conversationId/nodes/:nodeId
- Deletes a node and its descendants in the graph, but preserves nodes that are joined from multiple parents.

## Frontend Architecture
### 1. Screens & Layout

Screen 1 – Conversation list (sidebar)

- Shows all conversations from /api/conversations.
- "New conversation" button (reuses draft conversations if they exist).
- Allows renaming and deleting conversations via a context menu.
- Sidebar can be collapsed/expanded.

Screen 2 – Conversation view

- Layout:
  - Left sidebar: conversation list (can be hidden).
  - Main canvas: React Flow graph + inline chat controls.
- Graph area (React Flow)
  - Groups nodes into QA pairs: each visual node contains user question + AI answer.
  - Nodes can be dragged; positions are saved via /api/graph/:id/positions.
  - Supports creating draft nodes (empty question boxes) anchored to existing nodes.
  - Edges are directional, rendered as smooth steps, with arrows.
  - Controls: zoom, pan, fit-to-view, min/max zoom.
  - Double-click on a node opens an expanded chat view.
- Chat / Input
  - User types the question directly inside the graph node component.
  - Pressing Enter sends, Shift+Enter creates new lines.
  - Loading indicators show when waiting for AI response.

### 2. State Management with Zustand

Logical slices:
1. Conversation slice
    - currentConversationId
    - conversations list
    - Actions: fetchConversations, createConversation, persistDraftConversation, touchConversation, deleteConversation, updateConversationTitle, setCurrentConversation.
2. Messages slice
    - sendMessage(conversationId, content, fromNodeIds?)
3. Graph slice
    - graphByConversationId (nodes + edges)
    - loadingByConversationId, errorByConversationId
    - Actions: fetchGraph, setGraph, updateNodePositions, removeConversationGraph.
4. Theme slice
    - mode: 'light' | 'dark'
    - setMode, persisted in localStorage and applied via CSS variables.

### 3. Backend Architecture (Worker + Hono)


### 1. Request Flow (Send message)

1. Hono route /api/messages receives request.
2. Validate payload (conversationId, content).
3. Use D1 binding:
    - Insert user message into messages.
    - Create user and AI graph nodes.
    - Connect edges from previous nodes based on `fromNodeIds`.
4. Build AI API request:
    - If `fromNodeIds` exist, load messages for the ancestor nodes subgraph.
    - Map them into Gemini `contents` format (role: user/model, parts: text).
5. Call Google Gemini with API key `AI_API_KEY`.
6. On success:
    - Insert AI message into messages.
    - Insert AI node + edge.
    - Return both messages and graph delta.
7. On failure:
    - Try a second attempt.
    - If it still fails, return a clear 500 error message to the frontend.
8. If no `AI_API_KEY` is configured:
    - Fallback to echo mode using `buildEchoFromAncestors` for context-aware echoes.

### 2. DB Access Layer (implemented)

Helper functions (subset):
1. getConversationById(id)
2. createConversation(title)
3. listConversations()
4. createMessageWithAI(conversationId, content, fromNodeIds?, aiOverrideContent?)
5. getGraph(conversationId)
6. updateNodePositions(conversationId, positions[])
7. deleteConversation(conversationId)
8. listMessagesForNodeAncestors(conversationId, fromNodeIds, limit)
9. deleteNodeSubtreeRespectingJoins(conversationId, rootNodeId)

### 3. Security & Configuration (MVP)

- AI API key available via Worker environment binding `AI_API_KEY`.
- Frontend never sees this key.
- CORS to be configured in production (Cloudflare Worker + Pages origins).
- Basic client-side validation of message length.

### 4. Development & Deployment Workflow

## 1. Local Development

Use npm.
Monorepo:
- frontend/ (Vite + React + TS)
- backend/ (Worker + Hono)

Use:
- ESLint + Prettier for consistent formatting.
- Git + GitHub for version control.

## 2. Deployment Plan

Frontend:
- Build static assets with Vite.
- Deploy on Cloudflare Pages.

Backend:
- Deploy Worker with Wrangler to Cloudflare.
- Bind D1 database to Worker.

Set environment variables for AI API keys in Cloudflare dashboard or wrangler config.
